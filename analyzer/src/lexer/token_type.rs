use std::fmt::Display;

#[derive(Debug, Clone, PartialEq)]
pub enum TokenType {
    Assign,
    Plus,
    Minus,
    Multiply,
    Divide,
    Percent,
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessEqual,
    GreaterEqual,
    BitAnd,
    BitOr,
    BitXor,
    BitLeft,
    BitRight,
    And,
    Or,
    Bang,
    Tilde,
    Increment,
    Decrement,
    // OPERATORS END
    Identifier,

    OpenParen,
    CloseParen,
    OpenCurlyBrace,
    CloseCurlyBrace,
    OpenBracket,
    CloseBracket,

    // keywords
    Let,
    Fn,
    Break,
    Case,
    CharKeyword,
    Const,
    Continue,
    Default,
    Do,
    Double,
    Else,
    Enum,
    Float,
    For,
    If,
    Int,
    Bool,
    Return,
    Usize,
    Sizeof,
    Static,
    Struct,
    Switch,
    Void,
    While,
    Str,
    Impl,
    Pub,
    True,
    False,
    Defer,

    // keywords end
    Number,
    String,
    Char,
    Semicolon,
    Colon,
    Comma,
    Dot,
    Arrow,
    Eof,
}

impl Display for TokenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let content = match self {
            TokenType::Identifier => "Identifier",
            TokenType::OpenParen => "Open Parenthesis '('",
            TokenType::CloseParen => "Close Parenthesis ')'",
            TokenType::OpenCurlyBrace => "Open Curtly Brace '{'",
            TokenType::CloseCurlyBrace => "Close Curly Brace '}'",
            TokenType::OpenBracket => "Open Bracket '['",
            TokenType::CloseBracket => "Close Bracket ']'",
            TokenType::Number => "Number",
            TokenType::String => "String",
            TokenType::Char => "Char",
            TokenType::Semicolon => "Semicolon ';'",
            TokenType::Colon => "Colon ':'",
            TokenType::Comma => "Comma ','",
            TokenType::Dot => "Dot '.'",
            TokenType::Arrow => "Arrow '->'",
            TokenType::Eof => "Eof",
            TokenType::Assign => "Assign '='",
            TokenType::Plus => "Plus '+'",
            TokenType::Minus => "Minus '-'",
            TokenType::Multiply => "Multiply '*'",
            TokenType::Divide => "Divide '/'",
            TokenType::Percent => "Percent '%'",
            TokenType::Bang => "Bang '!'",
            TokenType::Equal => "Equal '=='",
            TokenType::NotEqual => "Not Equal '!='",
            TokenType::LessThan => "Less Than '<'",
            TokenType::GreaterThan => "Greater Than '>'",
            TokenType::LessEqual => "Less Than Equal '<='",
            TokenType::GreaterEqual => "Greater Than Equal '>='",
            TokenType::Tilde => "Tilde '~'",
            TokenType::BitAnd => "Bitwise And '&'",
            TokenType::BitOr => "Bitwise Or '|'",
            TokenType::BitXor => "Bitwise Xor '^'",
            TokenType::And => "And '&&'",
            TokenType::Or => "Or '||'",
            TokenType::Increment => "Increment '++'",
            TokenType::Decrement => "Decrement '--'",
            TokenType::Let => "Let Keyword",
            TokenType::Fn => "Fn Keyword",
            TokenType::Break => "Break Keyword",
            TokenType::Case => "Case Keyword",
            TokenType::CharKeyword => "Char Keyword",
            TokenType::Const => "Const Keyword",
            TokenType::Continue => "Continue Keyword",
            TokenType::Default => "Default Keyword",
            TokenType::Do => "Do Keyword",
            TokenType::Double => "Double Keyword",
            TokenType::Else => "Else Keyword",
            TokenType::Enum => "Enum Keyword",
            TokenType::Float => "Float Keyword",
            TokenType::For => "For Keyword",
            TokenType::If => "If Keyword",
            TokenType::Int => "Int Keyword",
            TokenType::Bool => "Bool Keyword",
            TokenType::Return => "Return Keyword",
            TokenType::Usize => "Usize Keyword",
            TokenType::Sizeof => "Sizeof Keyword",
            TokenType::Static => "Static Keyword",
            TokenType::Struct => "Struct Keyword",
            TokenType::Switch => "Switch Keyword",
            TokenType::Void => "Void Keyword",
            TokenType::While => "While Keyword",
            TokenType::Defer => "Defer Keyword",
            TokenType::Str => "Str Keyword",
            TokenType::Impl => "Impl Keyword",
            TokenType::Pub => "Pub Keyword",
            TokenType::True => "True Keyword",
            TokenType::False => "False Keyword",
            TokenType::BitLeft => "BitLeft '<<'",
            TokenType::BitRight => "BitRight '>>'",
        };

        return write!(f, "{}", content);
    }
}
